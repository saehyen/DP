# DP
## 동적 프로그래밍에 대한 예제 모음
- DP 의 기본은 재귀함수를 사용한다는 느낌을 받는 것이다.
- 기본적인 구성은 DP 테이블( bottom or top)을 구성한 뒤 테이블을 채워넣는 형식이다.

- 보통 피보나치 수열을 기본으로 생각한 뒤, 점화식을 생각나게 하는 문제들에 한하여 자주 쓰이게 된다.

1. 피보나치 수열
- 보통 재귀함수로만 구현하는 경우가 많은데 1번째 피보나치 파일을 통해 구현해본다면 6번째를 구현하기 위해 1을 한번 2를 2번 3을 2번.. 식으로 구현하게 된다.
- 이렇게 구현하게 된다면 시간복잡도가 엄청나게 올라간다.
- 이를 DP테이블을 통해 구현한다면 시간복잡도는 O(N)이 된다.

2. 1로 만들기
- 점화식으로 표현한다면 a1=min(ai-1,ai/2,ai/3,ai/5)+1이 된다.
- 따라서 DP를 사용한다면 아주 편하다.

3. 개미 전사
- 리스트의 원소를 더하되 연속하여 2개는 더하지 못한다.
- 최대값을 구하기 위해서 2가지 경우의 수를 비교한다.
- (i-1) 번째 원소를 결정한 경우 i 번째는 선택 불가이다.
- (i-2) 번째 원소를 결정한 경우 i 번째는 선택가능하다.
- 이를 식으로 하여 d[i] = max(d[i-1],d[i-2]+array[i]) 를 사용한다.

4. 바닥 공사
- 점화식으로 표현한다면 a1= ai-1+ai-2*2 가 된다.
- 따라서 DP 테이블을 구성한 뒤 d[1]=1, d[2]=3 , d[i] = (d[i-1]+2*d[i-2])를 수행하면 답이 나온다.

5. 효율적인 화폐 구성
- N가지 종류의 화폐가 존재할때 화폐들의 개수를 최소화하여 M원을 뽑아내는 문제이다.
- 그리디 알고리즘으로 해결할려고 하지말고 DP를 통해 구현하도록 하여야 한다.
- ai-k를 만드는 방법이 존재할 경우 ai = min(ai,ai-k+1)]
- ai-k를 만드는 방법이 존재하지 않을 경우 ai = 10,001
- 이 식을 DP로 구성하는 것은 쉽지 않다.
- for i in range(n):
-    for j in range(array[i], m+1):
-        if d[j-array[i]] != 10001 :
-            d[j]= min(d[j],d[j- array[i]] + 1)
- (이해하기 위해 여러번 읽어볼것) 마지막 리딩기록 : 2021.06.08
